package com.nsoft.github.data.local.room.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import com.nsoft.github.data.local.room.REPOSITORIES_TABLE_NAME
import com.nsoft.github.domain.model.GitRepository
import kotlinx.coroutines.flow.Flow

@Dao
interface GitRepositoryDao {
//    @Insert(onConflict = OnConflictStrategy.REPLACE)
    // The reasoning for the following change isn't as subtle or short ...
    // The problem we're solving is that, the "Favorites" table wasn't being persisted across restarts
    //
    // Since we're fetching new API results on every app restart, and REPLACE essentially
    // performs a DELETE followed by an INSERT, the DELETE triggers the FavoriteDao's CASCADE
    // which will also clear the linked favorites from their table once the "git_repository" entries
    // have been replaced (deleted and then inserted)
    //
    // So, we're gonna do something different. We will INSERT or UPDATE depending on whether the row
    // exists in the table in the repo layer, and just not use REPLACE here. That's why we're using IGNORE
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insert(gitRepository: GitRepository)

//    @Insert(onConflict = OnConflictStrategy.REPLACE)
    // Literally the same problem. Leave it commented out as a reminder to never fall into temptation
    // of "fixing" or "improving" this by changing it to REPLACE ...
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insertAll(repositories: List<GitRepository>)

    @Update
    suspend fun update(gitRepository: GitRepository)

    @Update
    suspend fun updateAll(repositories: List<GitRepository>)

    // These two will be ordered by the implicit "rowId" so that items that were inserted first
    // in the DB remain first in the select - we want to avoid implicit sorting by primary key
    // which we can't control and it's not infeasable that new data pulled from the API has
    // "lower" primary keys than the ones already inserted, thus messing up the item ordering.
    //
    // So, we will unfortunatelly have to change the PrimaryKey from the explicit repoID
    // (which is outside of our control) to a more implicit one called _databaseId which will be
    // autogenerated, and will essentially be the exact same thing to what 'rowId' is.
    //
    // That way, we will preserve the ordering of items in their natural "insertion order"
    // or rather, the order in which they came from the API.
    //
    // At first the idea was to use "rowId" but then later on it became obvious that implicit sorting
    // is done while INSERT-ing, so repos with smaller IDs took places. This is why we put in a new
    // autogenerated primary key called "_databaseId"

    @Query("SELECT * FROM ${REPOSITORIES_TABLE_NAME}")
    suspend fun getAllRepositories(): List<GitRepository>

    @Query("SELECT * FROM ${REPOSITORIES_TABLE_NAME}")
    fun getAllRepositoriesFlow(): Flow<List<GitRepository>>
}
